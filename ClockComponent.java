import javax.swing.JComponent;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Color;
import java.awt.BasicStroke;
import java.awt.geom.*;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.awt.Font;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;
/**
 * ClockComponent
 * 
 * @author William Chern
 * @version 1/13/2016 (start)
 * 
 */
public class ClockComponent extends JComponent implements ActionListener
{
    public static final int DIAMETER = 400;
    public static final int frameH = (int) Math.round(1.5*DIAMETER);
    public static final int frameW = (int) Math.round(1.5*DIAMETER);
    
    public void actionPerformed(ActionEvent e) {
        // what we want to happen in response to signal Event generated by Timer
        repaint();
    }

    public void paintComponent (Graphics g) {
        Graphics2D g2 = (Graphics2D) g; // type casting g into a Graphics2D object referenced by g2

        // translate graphical context to center of clock (make origin center of clock)
        g2.translate(frameH/2,frameW/2);
        
        // retrieve internal data from machine
        GregorianCalendar cal = new GregorianCalendar();
        int hour = cal.get(Calendar.HOUR);
        int minute = cal.get(Calendar.MINUTE);
        int second = cal.get(Calendar.SECOND);
        int millisecond = cal.get(Calendar.MILLISECOND);

        // draw clock face
        drawClockFace(g2);
        //draw clock hands
        drawClockHands(g2,hour,minute,second,millisecond);
    }

    private void drawClockFace(Graphics2D g2) {
        // draw outer circle for perimeter of clock, fill it with gray
        // construct instance of Ellipse2D class
        // create Ellipse with dimensions of DIAMETER and positioned at -DIAMETER/2, -DIAMETER/2 (because of translated origin, and flipped axes)
        Ellipse2D.Double face = new Ellipse2D.Double(-DIAMETER/2, -DIAMETER/2, DIAMETER, DIAMETER);
        g2.setStroke(new BasicStroke(4)); // invoke mutator method setStroke on Graphics2D object referenced by g2, modify value stroke thickness to 5 pts
        g2.setColor(Color.BLACK); // invoke mutator method setColor on Graphics2D object;set black color
        g2.fill(face);
        g2.setColor(new Color(150,150,150)); // invoke mutator method setColor on Graphics2D object;set gray color
        g2.draw(face);

        // "draw" numbers (using text)
        drawNumbersOnClockFace_Class(g2);

        // draw tick marks
        drawTickMarksOnClockFace_Chech(g2);

        // and anything else on the clock face (e.g. the date in the middle)
    }

    private void drawClockHands(Graphics2D g2, int h, int m, int s, int ms) {
        g2.setColor(new Color(200,200,200)); // invokes setColor mutator method on Graphics2D object referenced by g2, sets color to new Color object with gray color
        
        double rHr = DIAMETER*0.2; // calculates length of hour hand as 20% of the DIAMETER (shortest length), assigns value to new double value
        double rMin = DIAMETER*0.35; // calculates length of minute hand as 36% of the DIAMETER, assigns value to new double value
        double rSec = DIAMETER*0.36; // calculates length of second hand as 37% of the DIAMETER, assigns value to new double value
        
        double hrRadians = getHourRadians(h,m); // invokes getHourRadians method, which returns angle measurement for position of hour hand based on current hour and current minute
        double xHr = rHr*Math.cos(hrRadians); // invokes cosine static method in Math class, takes returned radian result and multiplies by radius of hour hand to get x position
        double yHr = rHr*Math.sin(hrRadians); // invokes sine static method in Math class, takes returned radian result and multiplies by radius of hour hand to get y position
        Line2D.Double hrHand = new Line2D.Double(0,0,xHr,yHr); // new Line2D.Double object referenced by hrHand from coordinates (0,0) [origin] to (xHr,yHr) position which was derived from current hour and minutes
        g2.setStroke(new BasicStroke(4)); // invokes setStroke mutator method on Graphics2D object referenced by g2, sets stroke thickness to 5
        g2.draw(hrHand); // invokes draw mutator method on Graphics2D object referenced by g2, draws hour hand in frame
        
        double minRadians = getMinuteRadians(m,s); // invokes getMinuteRadians method, returns angle measurement for angle position of minute hand based on current minutes and seconds
        double xMin = rMin*Math.cos(minRadians); // invokes cosine static method in Math class, takes returned radian result and multiplies by radius of minute hand to get current x position
        double yMin = rMin*Math.sin(minRadians); // invokes sine static method in Math class, takes returned radian result and multiplies by radius of minute hand to get current y position
        Line2D.Double minHand = new Line2D.Double(0,0,xMin,yMin); // new Line2D.Double object referenced by minHand from origin to (xMin, yMin) position derived from angle and minutes/seconds
        g2.setStroke(new BasicStroke(3)); // invokes setStroke mutator method on Graphics2D object referenced by g2, sets stroke thickness to 4
        g2.draw(minHand); // invokes draw mutator method on Graphics2D object referenced by g2, draws minute hand in frame
        
        double secRadians = getSecondRadians(s,ms); // invokes getSecondRadians method, returns angle measurement for angle position of second hand based on current seconds
        double xSec = rSec*Math.cos(secRadians); // invokes cosine static method in Math class, takes returned radian result and multiplies by radius of second hand to get current x position
        double ySec = rSec*Math.sin(secRadians); // invokes sine static method in Math class, takes returned radian result and multiplies by radius of second hand to get current y position
        Line2D.Double secHand = new Line2D.Double(0,0,xSec,ySec); // new Line2D.Double object referenced by secHand from origin to (xMin, yMin) position derived from angle and seconds
        g2.setStroke(new BasicStroke(2)); // invokes setStroke mutator method on Graphics2D object referenced by g2, sets stroke thickness to 2
        g2.setColor(new Color(204,0,0)); // invokes setColor mutator method on Graphics2D object referenced by g2, sets color to a dark red color
        g2.draw(secHand); // invokes draw mutator method on Graphics2D object referenced by g2, draws second hand in frame
    }

    private void drawTickMarksOnClockFace_Chech(Graphics2D g2) {
        g2.setStroke(new BasicStroke(2)); // set stroke thickness to 2
        g2.setColor(new Color(181,181,181)); // set gray color
        // draw tick marks along inner perimeter
        double r1 = DIAMETER*0.34; // hypotenuse value of inner end point of tick mark
        double r2 = DIAMETER*0.36;
        for (int theta=0; theta<360; theta+=6) { // loop through circle via 360 deg, each tick mark separated 6 degrees
            double thetaRadians = Math.toRadians(theta); // convert Theta from degrees to radians
            double x1 = r1*Math.cos(thetaRadians); // x1 is the first radius fraction multipled by cos(thetaRad)
            double y1 = r1*Math.sin(thetaRadians); // all (x,y) values converted as Polar Coordinates
            double x2 = r2*Math.cos(thetaRadians); // cosine is adjacent over hypotenuse, and the adjacent side of the triangle formed is the x coordinate, x is equal to cos of angle times the hypotenuse
            double y2 = r2*Math.sin(thetaRadians);

            if (theta%5==0) g2.setStroke(new BasicStroke(5)); // if angle is divisible by 5 (corresponds to hour), make tick thicker
            else g2.setStroke(new BasicStroke(2));

            Line2D.Double tick = new Line2D.Double(x1,y1,x2,y2); // new tick mark from (x1,y1) to (x2,y2)
            g2.draw(tick);
        }
    }

    private double getHourRadians(int hr, int min) { // takes in parameters of hour and minute
        return Math.toRadians((30*hr)-90+((min/60)*(30)));
        // calculates radian angle of hour based on current hour and current minute
        // invokes toRadians static method in Math class to convert degrees to radians
    }

    private double getMinuteRadians(int min, int sec) { // parameter variable for minute
        return Math.toRadians((6*min)-90+(sec/10));
        // calculates radian angle of hour based on current minute
        // invokes toRadians static method in Math class to convert degrees to radians
    }

    private double getSecondRadians(int sec, int milliSec) { // parameter variable for the second
        return Math.toRadians((6*sec)-90+(milliSec/1000)*6);
        // calculates radian angle of hour based on current second
        // invokes toRadians static method in Math class to convert degrees to radians
    }

    private void drawNumbersOnClockFace_HW(Graphics2D g2) {
        g2.setStroke(new BasicStroke(3)); // set stroke thickness to 3
        g2.setColor(new Color(230,230,230)); // set white color
        double hrHyp = DIAMETER*0.4;
        int hour = 1; // used in loop to increment which hour is drawn
        for (int theta=300; theta<660; theta+=30) {
            // loop through circle via 360 deg, each hour number is 30 degrees apart
            // since unit circle is flipped due to flipped coordinate axes, start at 300 degrees, which is the normal position of 1
            // loop around 360 degrees (to 660, started from 300), so that all 12 hours are accounted for
            double thetaRadians = Math.toRadians(theta); // converts to radians
            double x = hrHyp*(Math.cos(thetaRadians)); // x value is cos(thetaRadians) - polar coordinates
            double y = hrHyp*Math.sin(thetaRadians);

            g2.drawString(Integer.toString(hour), (float) x, (float) y); // draw hour at specified x,y location
            hour++; // increment to next hour
        }
    }

    private void drawNumbersOnClockFace_Class(Graphics2D g2) {
        g2.setStroke(new BasicStroke(3)); // set stroke thickness to 3
        g2.setColor(new Color(230,230,230)); // set white color
        double fontSize = DIAMETER*0.06;
        g2.setFont(new Font(Font.SANS_SERIF, Font.BOLD, (int)fontSize)); 
        // invoke setFont mutator method on Graphics2D object referenced by g2, sets font state to Sans Serif, Bold&Italics, with double value fontSize (dependent on DIAMETER)

        // "draw" numbers (using text)
        double hrHyp = DIAMETER*0.42; // hypotenuse for drawing the hour numbers

        for (int hr=1; hr<=12; hr++) {
            String hrStr = Integer.toString(hr);
            // invoke toString static method of Integer class to convert hr to a String so that it can be passed as a String parameter var into drawString method later

            double xOffSet = DIAMETER*0.02*hrStr.length(); // offset for x-coordinate calculated based on diameter and number of digits
            double yOffSet = fontSize/2.25; // offset for y-coordinate calculated as a fraction of current fontSize

            double thetaHr = getHourRadians(hr,0);

            double x = (hrHyp*Math.cos(thetaHr))-xOffSet; // x-coordinate based on polar coordinate, subtracted xOffSet to move horizontally to the left
            double y = (hrHyp*Math.sin(thetaHr))+yOffSet; // y-coordinate based on polar coordinate, shifts numbers down vertically

            g2.drawString(hrStr,(float) x,(float) y); // invoke drawString mutator method on Graphics2D object referenced by g2, casting doubles x and y to float values
        }
    }
}
